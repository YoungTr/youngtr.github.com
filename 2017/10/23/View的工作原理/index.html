<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,Android源码分析," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="1. ViewRootImplView 的绘制流程从 ViewRootImpl 的 performTraversals 方法开始，经过 measu、layout 和 draw 三个过程将一个 View 绘制出来。   measure 过程决定了 View 的宽高，Measure 完成以后，可以通过 getMeasuredWidth 和 getMeasureHeight 方法来获取 View 测量后">
<meta name="keywords" content="Android,Android源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="View的工作原理">
<meta property="og:url" content="https://youngtr.github.io/2017/10/23/View的工作原理/index.html">
<meta property="og:site_name" content="YoungTr">
<meta property="og:description" content="1. ViewRootImplView 的绘制流程从 ViewRootImpl 的 performTraversals 方法开始，经过 measu、layout 和 draw 三个过程将一个 View 绘制出来。   measure 过程决定了 View 的宽高，Measure 完成以后，可以通过 getMeasuredWidth 和 getMeasureHeight 方法来获取 View 测量后">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://youngtr.github.io/images/performTraversals.png">
<meta property="og:image" content="https://youngtr.github.io/images/view-measure-spec.png">
<meta property="og:updated_time" content="2018-06-05T04:57:32.976Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="View的工作原理">
<meta name="twitter:description" content="1. ViewRootImplView 的绘制流程从 ViewRootImpl 的 performTraversals 方法开始，经过 measu、layout 和 draw 三个过程将一个 View 绘制出来。   measure 过程决定了 View 的宽高，Measure 完成以后，可以通过 getMeasuredWidth 和 getMeasureHeight 方法来获取 View 测量后">
<meta name="twitter:image" content="https://youngtr.github.io/images/performTraversals.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://youngtr.github.io/2017/10/23/View的工作原理/"/>





  <title>View的工作原理 | YoungTr</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YoungTr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://youngtr.github.io/2017/10/23/View的工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YoungTr">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YoungTr">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">View的工作原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-23T09:44:06+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-ViewRootImpl"><a href="#1-ViewRootImpl" class="headerlink" title="1. ViewRootImpl"></a>1. ViewRootImpl</h3><p>View 的绘制流程从 ViewRootImpl 的 performTraversals 方法开始，经过 measu、layout 和 draw 三个过程将一个 View 绘制出来。</p>
<p><img src="/images/performTraversals.png" alt="performTraversals"></p>
<ol>
<li><p>measure 过程决定了 View 的宽高，Measure 完成以后，可以通过 <strong>getMeasuredWidth</strong> 和 <strong>getMeasureHeight</strong> 方法来获取 View 测量后的宽高。</p>
</li>
<li><p>layout 过程决定了 View 四个顶点的位置，可以通过 <strong>getWidth</strong> 和 <strong>getHeight</strong> 方法得到最终宽高。</p>
</li>
<li><p>draw 过程决定了 View 的显示。</p>
</li>
</ol>
<h3 id="2-理解-MeasureSpec"><a href="#2-理解-MeasureSpec" class="headerlink" title="2. 理解 MeasureSpec"></a>2. 理解 MeasureSpec</h3><p>MeasureSpec 很大程度上决定了一个 View 的尺寸规格，这个工程还受父容器的影响，因为父容器影响 View 的 MeasureSpec 的创建过程。</p>
<h4 id="2-1-MeasureSpec"><a href="#2-1-MeasureSpec" class="headerlink" title="2.1 MeasureSpec"></a>2.1 MeasureSpec</h4><p>MeasureSpec 代表一个 32 位 int 值，<strong>高2位</strong>代表 SpecMode，<strong>低30位</strong>代表 SpecSize。 SpecMode 是指测量模式，SpecSize 是指在某种测量模式下的规格大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private static final int MODE_SHIFT = 30;</div><div class="line">private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;</div><div class="line">public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;</div><div class="line">public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;</div><div class="line">public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">public static int makeMeasureSpec(int size, int mode) &#123;</div><div class="line">    if (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">        return size + mode;</div><div class="line">    &#125; else &#123;</div><div class="line">        return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static int getMode(int measureSpec) &#123;</div><div class="line">    return (measureSpec &amp; MODE_MASK);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static int getSize(int measureSpec) &#123;</div><div class="line">    return (measureSpec &amp; ~MODE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SpecMode 有三类：</p>
<p><strong>UNSPECIFIED</strong></p>
<p>父容器对 View 没有任何限制，要多大给多大。（一般用于系统内部，表示一种测量状态）</p>
<p><strong>EXACTLY</strong></p>
<p>父容器已经检测出 View 所需要的<strong>精确大小</strong>，View 的最终大小就是 SpecSize 所指定的值。它对应于 LayoutParams 中的 <strong>match_parent</strong> 和<strong>具体数值</strong>这两种模式。</p>
<p><strong>AT_MOST</strong></p>
<p>父容器指定一个可用大小即 SpecSize，View 的大小不能大于这个值。它对应于 LayoutParams 中的 <strong>wrap_content</strong> 。</p>
<h4 id="2-2-MeasureSpec-和-LayoutParams-的对应关系"><a href="#2-2-MeasureSpec-和-LayoutParams-的对应关系" class="headerlink" title="2.2 MeasureSpec 和 LayoutParams 的对应关系"></a>2.2 MeasureSpec 和 LayoutParams 的对应关系</h4><p>在 View 测量的时候，系统会将 LayoutParams 在父容器的约束下转换成对应的 MeasureSpec，然后再根据这个 MeasureSpec 来确定 View 测量后的宽高。</p>
<p>需要注意，MeasureSpec 不是唯一由 LayoutParams 决定的，LayoutParams 需要和父容器一起才能决定 View 的 MeasureSpec。</p>
<p>对顶级 View（即 DecorView），其 MeasureSpec 由窗口的尺寸和其自身的 LayoutParams 来共同决定；对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定。</p>
<p><strong>MeasureSpec 一旦确定后，onMeasure 中就可以确定 View 的测量宽高。</strong></p>
<p>对 DecorView 来说，ViewRootImpl 中 measureHierarchy 方法，其展示了 DecorView 的 MeasureSpec 的创建过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
<p><strong>desiredWindowWidth，desiredWindowHeight是屏幕的尺寸。</strong></p>
<p>getRootMeasureSpec 方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class="line">        int measureSpec;</div><div class="line">        switch (rootDimension) &#123;</div><div class="line"></div><div class="line">        case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            // Window can&apos;t resize. Force root view to be windowSize.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            break;</div><div class="line">        case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            // Window can resize. Set max size for root view.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            // Window wants to be an exact size. Force root view to be that size.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>DecorView 的 MeasureSpec 遵守如下规则：</p>
<ul>
<li>LayoutParams.MATCH_PARENT：精确模式，大小就是窗口大小；</li>
<li>LayoutParams.WRAP_CONTENT：最大模式，大小不定，但不能超过窗口大小；</li>
<li>固定大小（比如100dp）：精确模式，大小为 LayoutParams 中指定大小；</li>
</ul>
<p>对于一般的 View，View 的 measure 由 ViewGroup 传递过来，ViewGroup 的 measureChildMargins 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected void measureChildWithMargins(View child,</div><div class="line">        int parentWidthMeasureSpec, int widthUsed,</div><div class="line">        int parentHeightMeasureSpec, int heightUsed) &#123;</div><div class="line">    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                    + widthUsed, lp.width);</div><div class="line">    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                    + heightUsed, lp.height);</div><div class="line"></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法对子元素进行 measure ，在调用子元素的 measure 方法 之前会通过 getChildMeasureSpec 方法来获取子元素的 MeasureSpec 。</p>
<p>子元素的 MeasureSpec 的创建与父容器的 MeasureSpec 和子元素的 LayoutParams有关，还与 View 的 margin 及 padding 有关，具体情况可以看一下 ViewGroup 的 getChildMeasureSpec 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</div><div class="line">    int specMode = MeasureSpec.getMode(spec);</div><div class="line">    int specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">    int size = Math.max(0, specSize - padding);</div><div class="line"></div><div class="line">    int resultSize = 0;</div><div class="line">    int resultMode = 0;</div><div class="line"></div><div class="line">    switch (specMode) &#123;</div><div class="line">    // Parent has imposed an exact size on us</div><div class="line">    case MeasureSpec.EXACTLY:</div><div class="line">        if (childDimension &gt;= 0) &#123;</div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            // Child wants to be our size. So be it.</div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            // Child wants to determine its own size. It can&apos;t be</div><div class="line">            // bigger than us.</div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    // Parent has imposed a maximum size on us</div><div class="line">    case MeasureSpec.AT_MOST:</div><div class="line">        if (childDimension &gt;= 0) &#123;</div><div class="line">            // Child wants a specific size... so be it</div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            // Child wants to be our size, but our size is not fixed.</div><div class="line">            // Constrain child to not be bigger than us.</div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            // Child wants to determine its own size. It can&apos;t be</div><div class="line">            // bigger than us.</div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    // Parent asked to see how big we want to be</div><div class="line">    case MeasureSpec.UNSPECIFIED:</div><div class="line">        if (childDimension &gt;= 0) &#123;</div><div class="line">            // Child wants a specific size... let him have it</div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            // Child wants to be our size... find out how big it should</div><div class="line">            // be</div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            // Child wants to determine its own size.... find out how</div><div class="line">            // big it should be</div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    //noinspection ResourceType</div><div class="line">    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法主要作用是根据父容器的 MeasureSpec 同时结合 View 本身的 LayoutParams 来确定子元素的 MeasureSpec，参数中的 padding 是指父容器中已占用的空间大小，因此子元素可用大小为父容器的尺寸减去 padding 。</p>
<p>普通 View 的 MeasureSpec 创建规则</p>
<p><img src="/images/view-measure-spec.png" alt="view-measure-spec"></p>
<ul>
<li>当 View 采用固定宽高时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是 <strong>MeasureSpec.EXACTLY</strong> 其大小都是遵循 LayoutParams 中的大小。</li>
<li>当 View 的宽高是 match_parent 时，如果父容器是 MeasureSpec.EXACTLY 模式，那么 View 也是 MeasureSpec.EXACTLY 模式其大小是父容器的剩余空间；如果父容器是 MeasureSpec.AT_MOST 模式，那么 View 也是 MeasureSpec.AT_MOST 模式其大小不会超过父容器的剩余空间。</li>
<li>当 View 的宽高是 wrap_content 时，不管父容器是 MeasureSpec.EXACTLY 还是 MeasureSpec.AT_MOST ，View 总是 MeasureSpec.AT_MOST 模式并且大小不能超过父容器剩余空间。 </li>
</ul>
<h3 id="3-View-的工作流程"><a href="#3-View-的工作流程" class="headerlink" title="3. View 的工作流程"></a>3. View 的工作流程</h3><h4 id="3-1-measure-过程"><a href="#3-1-measure-过程" class="headerlink" title="3.1 measure 过程"></a>3.1 measure 过程</h4><p>如果是一个原始的 View ，那么通过 measure 就可以完成其测量；如果是一个 ViewGroup ，除了完成自己的测量，还会遍历去调用所有子元素的 measure 方法。</p>
<h5 id="3-1-1-View-的-measure-工程"><a href="#3-1-1-View-的-measure-工程" class="headerlink" title="3.1.1 View 的 measure 工程"></a>3.1.1 View 的 measure 工程</h5><p>View 的 measure 工程由其 measure 方法完成，该方法是一个 final 类型的方法，在该方法中会其调用 onMeasure 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>setMeasuredDimension 方法会设置 View 的宽高，只需要看一下 getDefaultSize 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">       int result = size;</div><div class="line">       int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">       int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">       switch (specMode) &#123;</div><div class="line">       case MeasureSpec.UNSPECIFIED:</div><div class="line">           result = size;</div><div class="line">           break;</div><div class="line">       case MeasureSpec.AT_MOST:</div><div class="line">       case MeasureSpec.EXACTLY:</div><div class="line">           result = specSize;</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       return result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>对于 MeasureSpec.AT_MOST 和 MeasureSpec.EXACTLY ，getDefaultSize 返回的大小就是 measureSpec 中的 specSize，而这个 specSize 就是 View 测量后的大小。</p>
<p>对 MeasureSpec.UNSPECIFIED ，View 的宽高是 getSuggestedMinimumWidth 和 getSuggestedMinimumHeight 的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected int getSuggestedMinimumWidth() &#123;</div><div class="line">    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 View 没有设置背景，那么 View 的宽为 mMinWidth，即 android:minWidth 属性所指定的值，默认为 0；如果设置了背景，则 View 的宽为 max(mMinWidth,，mBackground.getMinimumWidth())</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public int getMinimumWidth() &#123;</div><div class="line">    final int intrinsicWidth = getIntrinsicWidth();</div><div class="line">    return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getMinimumWidth 就是返回 Drawable 的原始宽度。</p>
<p>可以得出这样一个结论：直接继承 View 自定义控件需要重写 onMeasure 方法并设置 wrap_content 时自身大小，否则布局中使用 wrap_content 就相当于使用 match_parent。原因见 <em>普通 View 的 MeasureSpec 创建规则</em></p>
<h5 id="3-1-2-ViewGrop-的-measure-过程"><a href="#3-1-2-ViewGrop-的-measure-过程" class="headerlink" title="3.1.2 ViewGrop 的 measure 过程"></a>3.1.2 ViewGrop 的 measure 过程</h5><p>对 ViewGroup 来说，除了完成自己的 measure 过程，还会遍历调用所有子元素的 measure 方法，各个子元素再递归去执行这个过程。</p>
<p>ViewGroup 是一个抽象类，没有重写 View 的 onMeasure 方法，提供了一个 measureChildren 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    final int size = mChildrenCount;</div><div class="line">    final View[] children = mChildren;</div><div class="line">    for (int i = 0; i &lt; size; ++i) &#123;</div><div class="line">        final View child = children[i];</div><div class="line">        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ViewGroup 在 measure 是，会对每一个子元素进行 measure：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">protected void measureChild(View child, int parentWidthMeasureSpec,</div><div class="line">        int parentHeightMeasureSpec) &#123;</div><div class="line">    final LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mesureChild 思想就是获取子元素的 LayoutParams，然后再通过 getChildMeasureSpec 来创建子元素的 MeasureSpec，接着将 MeasureSpec 直接传递给 View 的 measure 方法来进行测量。</p>
<p>ViewGroup 并没有定义其测量的具体过程，因为不同的布局实现细节不同，无法统一处理，通过 LinearLayout 的 onMeasure 方法分析 ViewGroup 的 measure 过程。</p>
<p>LinearLayout 的 onMeasure 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    if (mOrientation == VERTICAL) &#123;</div><div class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125; else &#123;</div><div class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里查看一下 measureVertical 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// See how tall everyone is. Also remember max width.</div><div class="line"></div><div class="line"> 	for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">         final View child = getVirtualChildAt(i);</div><div class="line">         ....</div><div class="line">     // Determine how big this child would like to be. If this or</div><div class="line">     / previous children have given a weight, then we allow it to</div><div class="line">     / use all available space (and we will shrink things later</div><div class="line">     // if needed).</div><div class="line">     </div><div class="line">     measureChildBeforeLayout(</div><div class="line">            child, i, widthMeasureSpec, 0, heightMeasureSpec,</div><div class="line">             totalWeight == 0 ? mTotalLength : 0);</div><div class="line">         if (oldHeight != Integer.MIN_VALUE) &#123;</div><div class="line">              lp.height = oldHeight;</div><div class="line">          &#125;</div><div class="line">          final int childHeight = child.getMeasuredHeight();</div><div class="line">          final int totalLength = mTotalLength;</div><div class="line">          mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class="line">                 lp.bottomMargin + getNextLocationOffset(child));</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>系统会遍历子元素并对每个子元素执行 measureChildBeforeLayout 方法，这个方法内部会调用子元素的 measure 方法，各个子元素就开始依次进入 measure 过程，并行会通过 mTotalLength 变量来存储 LinearLayout 在竖直方向的初步高度。</p>
<p>当子元素测量完毕后，LinearLayout 会测量自己的大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Add in our padding</div><div class="line">mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line">int heightSize = mTotalLength;</div><div class="line"></div><div class="line">// Check against our minimum height</div><div class="line">heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</div><div class="line"></div><div class="line">// Reconcile our calculated size with the heightMeasureSpec</div><div class="line">int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</div><div class="line">heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line">setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">               heightSizeAndState);</div></pre></td></tr></table></figure>
<p>View 的 measure 过程是三大流程中最复杂的一个，measure 完成以后，通过 getMeasuredWidth/Height 方法可以正确地获取到 View 的测量宽高。在某些极端情况下，系统需要多次 measure 才能确定最终的测量宽高，这样在 onMeasure 方法中拿到测量的宽高可能是不准确的。一个比较好的方法是在 onLayout 方法中去获取 View 的测量宽高或者最终的宽高。</p>
<h4 id="3-2-layout-过程"><a href="#3-2-layout-过程" class="headerlink" title="3.2 layout 过程"></a>3.2 layout 过程</h4><p>Layout 的作用是 ViewGroup 用来确定子元素的位置，当 ViewGroup 的位置确定后，它在 onLayout 中会遍历所有子元素并调用 layout 方法，在 layout 方法中 onLayout 方法又会被调用。</p>
<p>layout 的方法确定 View 本身的位置，onLayout 方法则会确认所有子元素的位置。</p>
<p>View 的 layout 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</div><div class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int oldL = mLeft;</div><div class="line">    int oldT = mTop;</div><div class="line">    int oldB = mBottom;</div><div class="line">    int oldR = mRight;</div><div class="line"></div><div class="line">    boolean changed = isLayoutModeOptical(mParent) ?</div><div class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">        onLayout(changed, l, t, r, b);</div><div class="line"></div><div class="line">        if (shouldDrawRoundScrollbar()) &#123;</div><div class="line">            if(mRoundScrollbarRenderer == null) &#123;</div><div class="line">                mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            mRoundScrollbarRenderer = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">        ListenerInfo li = mListenerInfo;</div><div class="line">        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">            int numListeners = listenersCopy.size();</div><div class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，setFrame 方法设定 View 四个顶点的位置，即初始化 mLeft、mTop、mRight、mBottom 四个值，View 的四个顶点的位置一旦确定，View 在父容器中的位置也就确定了；接着会调用 onLayout 方法，作用是父容器确定子元素的位置，其实现与具体的布局有关。</p>
<p>LinearLayout 的 onLayout 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    if (mOrientation == VERTICAL) &#123;</div><div class="line">        layoutVertical(l, t, r, b);</div><div class="line">    &#125; else &#123;</div><div class="line">        layoutHorizontal(l, t, r, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>layoutVertical 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">  void layoutVertical(int left, int top, int right, int bottom) &#123;</div><div class="line">	</div><div class="line">......</div><div class="line"></div><div class="line">      for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">          final View child = getVirtualChildAt(i);</div><div class="line">          if (child == null) &#123;</div><div class="line">              childTop += measureNullChild(i);</div><div class="line">          &#125; else if (child.getVisibility() != GONE) &#123;</div><div class="line">              final int childWidth = child.getMeasuredWidth();</div><div class="line">              final int childHeight = child.getMeasuredHeight();</div><div class="line">              </div><div class="line">              final LinearLayout.LayoutParams lp =</div><div class="line">                      (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">              </div><div class="line">              int gravity = lp.gravity;</div><div class="line">              if (gravity &lt; 0) &#123;</div><div class="line">                  gravity = minorGravity;</div><div class="line">              &#125;</div><div class="line">              final int layoutDirection = getLayoutDirection();</div><div class="line">             	</div><div class="line">		......</div><div class="line"></div><div class="line">              if (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                  childTop += mDividerHeight;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              childTop += lp.topMargin;</div><div class="line">              setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                      childWidth, childHeight);</div><div class="line">              childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line"></div><div class="line">              i += getChildrenSkipCount(child, i);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>此方法会遍历所有子元素并调用 setChildFrame 方法来为子元素指定对应位置，childTop 会逐渐变大，这意味着后面的子元素会被放置在靠下的位置。</p>
<p>setChildFrame 方法仅仅是调用子元素的 layout 方法，这样父元素在 layout 方法中完成自己的定位后，就通过调用 onLayout 方法去调用子元素的 layout 方法，子元素会通过自己的 layout 方法确定自己的位置，这样一层一层传递下去就完成整个 View 树的 layout 过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private void setChildFrame(View child, int left, int top, int width, int height) &#123;        </div><div class="line">    child.layout(left, top, left + width, top + height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-draw-过程"><a href="#3-3-draw-过程" class="headerlink" title="3.3 draw 过程"></a>3.3 draw 过程</h4><p>Draw 过程是将 View 绘制到屏幕上，View 的绘制流程遵循一下几个步骤：</p>
<ol>
<li>绘制背景 background.draw(canvas)</li>
<li>绘制自己 (onDraw)</li>
<li>绘制 children (dispatchDraw)</li>
<li>绘制装饰 (onDrawScrollBars)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public void draw(Canvas canvas) &#123;</div><div class="line">    final int privateFlags = mPrivateFlags;</div><div class="line">    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * Draw traversal performs several drawing steps which must be executed</div><div class="line">     * in the appropriate order:</div><div class="line">     *</div><div class="line">     *      1. Draw the background</div><div class="line">     *      2. If necessary, save the canvas&apos; layers to prepare for fading</div><div class="line">     *      3. Draw view&apos;s content</div><div class="line">     *      4. Draw children</div><div class="line">     *      5. If necessary, draw the fading edges and restore layers</div><div class="line">     *      6. Draw decorations (scrollbars for instance)</div><div class="line">     */</div><div class="line"></div><div class="line">    // Step 1, draw the background, if needed</div><div class="line">    int saveCount;</div><div class="line"></div><div class="line">    if (!dirtyOpaque) &#123;</div><div class="line">        drawBackground(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // skip step 2 &amp; 5 if possible (common case)</div><div class="line">    final int viewFlags = mViewFlags;</div><div class="line">    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</div><div class="line">    boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</div><div class="line">    if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">        // Step 3, draw the content</div><div class="line">        if (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">        // Step 4, draw the children</div><div class="line">        dispatchDraw(canvas);</div><div class="line"></div><div class="line">        // Overlay is part of the content and draws beneath Foreground</div><div class="line">        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Step 6, draw decorations (foreground, scrollbars)</div><div class="line">        onDrawForeground(canvas);</div><div class="line"></div><div class="line">        // we&apos;re done...</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ......</div></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Android源码分析/" rel="tag"># Android源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/18/Android-Glide/" rel="next" title="Android 图片加载框架 Glide">
                <i class="fa fa-chevron-left"></i> Android 图片加载框架 Glide
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/24/singleton/" rel="prev" title="单例模式">
                单例模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="YoungTr" />
          <p class="site-author-name" itemprop="name">YoungTr</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ViewRootImpl"><span class="nav-number">1.</span> <span class="nav-text">1. ViewRootImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-理解-MeasureSpec"><span class="nav-number">2.</span> <span class="nav-text">2. 理解 MeasureSpec</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-MeasureSpec"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 MeasureSpec</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-MeasureSpec-和-LayoutParams-的对应关系"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 MeasureSpec 和 LayoutParams 的对应关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-View-的工作流程"><span class="nav-number">3.</span> <span class="nav-text">3. View 的工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-measure-过程"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 measure 过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-View-的-measure-工程"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 View 的 measure 工程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-ViewGrop-的-measure-过程"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 ViewGrop 的 measure 过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-layout-过程"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 layout 过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-draw-过程"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 draw 过程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YoungTr</span>
</div>

        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
